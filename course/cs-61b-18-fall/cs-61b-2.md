# CS 61B \(2\)

## 6. ALists, Resizing, vs. SLists

**A Last Look at Linked Lists**

* 首先回顾了之前实现的链表主要操作

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.07.09-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.07.16-pm.png)

* 对于链表来说因为没有相应的索引，所以要得到某个数需要遍历全链表来得到这个数，平均的时间复杂度是O\(n\)
* 如果有可能使用Array，那么这个时间复杂度就会下降到O\(1\)

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.07.23-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.07.28-pm.png)

**Naive Array Lists**

* Array主要的特点就是Random Access - 随机访问，在硬件中的存储是连续的地址，因而在随机访问的时候就会非常非常快，而链表所指向的地址则是离散且分散的
* 这里提到了cs61c 比较偏向底层，有时间可以看一看

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.08.42-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.08.46-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.08.52-pm.png)

在这里具体的实现是非常重要也需要自己实际去做一遍的，不要因为简单就一下跳过:

* 规律是每次新加数的index就是size，因为size是从0开始的，所以每次对size同时进行调整即可
* 通过对size的控制，就可以做到随机访问

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.08.58-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.09.04-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.09.11-pm.png)

* 因为实际控制这个array的是size，所以对于remove来说，只需要调整size，并返还现在remove的就可以
* 从一般意义上说，并不需要对之前的数进行复制，但是如果这个不是intArray，那么其实是需要对最后一位进行操作，并将值设置为Null的，因为涉及到了garbage collection

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.09.16-pm%20%281%29.png)

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.09.21-pm.png)

**Resizing Arrays**

因为在java以及c之类的静态语言中，每次需要申请一个定额的空间，因此会出现一个空间用尽的问题，具体来讲就是超过了整个array的长度，这时候就需要对array进行resize

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.11.46-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.12.05-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.12.12-pm.png)

具体实现来说:

* 先new一个新的array，然后将之前的数复制到这个新的array里面，然后再将新的值放去新array里

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.12.47-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.12.53-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.12.57-pm.png)

这种处理方法的弊端是慢，因为对于array来说，只对size + 1进行复制，需要进行的操作比较多，所以后面实际实现的是倍增法

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.13.02-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.14.07-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.14.13-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.14.19-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.14.25-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.14.29-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.14.33-pm%20%281%29.png)

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.14.38-pm.png)

* 倍增法的思路可以有效地将整体的运算时间进行下降

**Generic ALists**

通用的ArrayList，需要不指定特殊的数据种类，而根据需要来设置实际存储的值

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.17.00-pm.png)

这里比较重要的是：

* （Glorp \[\]）new Object\[8\] 这个操作，目前来说还不是很清楚，在后面的casting里面应该会涉及到

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.17.07-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.17.12-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.17.25-pm.png)

这里主要是设为null之后，Java会清空不需要的objects，从而不会使原来的指向关系和存储的数值都变成“游荡”的孤儿。

**Obscurantism in Java**

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.18.25-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.18.32-pm.png)

* 主要是一些编程技巧，这里应该使用Private来限制其他人对这个对象的访问

## 7. Testing

程序员需要对code进行test来确保他们的程序能够运行，即使如此也很难确保程序能够正常运行，所谓的test都是尽可能接近程序的模拟来帮助debug。

#### **Ad Hoc Testing vs. JUnit**

```java
public static void testSort() {
    String[] input = {"I", "have", "an", "egg"};
    String[] expected = {"an", "egg", "have", "I"};
    Sort.sort(input);

    if (input != expected) {  // 这里如果写了 != 实际比较的事两者的地址是否一样
        System.out.println("Error!");
    }
    
    // 使用这种写法就是比较这个string list里面每一个元素是否一样    
    if (!java.util.Arrays.equals(input, expected)) {  
        System.out.println("Error!");
    }
}
```

下面的新写法就是尝试不实用java.util.Arrays，直接使用循环

![](../../.gitbook/assets/screen-shot-2018-12-09-at-4.44.04-pm.png)

实际coding的过程中，jUnit会自动做这些事情，类似于Python的断言函数来自动报错和检查

* org.junit.Assert.assertArrayEquals\(expected, input\);

![](../../.gitbook/assets/screen-shot-2018-12-09-at-4.44.09-pm.png)

* deprecated
  * 有时候因为代码修改需要淘汰一些函数，这里的问题是为什么不remove这个函数
  * 主要是为了保证以前的code也是可以运行的，这样可以做一个缓慢的过度

#### **Selection Sort**

* 永远把最小的提前

![](../../.gitbook/assets/screen-shot-2018-12-09-at-4.45.14-pm.png)

```java
// 找到最小的值

public static String findSmallest(String[] x) {
    int smallestIndex = 0;
    for (int x = 0; i < x.length; i += 1) {
        if (x[i] < x[smallestIndex]) { // 这里因为比较的事字符串，所以会报错
            smallestIndex = i;
        }
    }
    return smallestIndex;
}

// 修正

public static String findSmallest(String[] x) {
    int smallestIndex = 0;
    for (int x = 0; i < x.length; i += 1) {
        int cmp = x[i].compareTo(x[smallestIndex]); // 改成字符串比较
        if (cmp < 0 ) {
            smallestIndex = i;
        }
    }
    return smallestIndex;
}
```

Josh Hug真的是非常好的老师，在上课的过程中讲了如何debug，而且是从一个完全初学者的角度去理解，实现了找到最小的之后，只需要对内容进行swap即可。

```java
public static void Swap(String x[], int a , int b){
    String temp = x[a];
    x[a] = x[b];
    x[b] = temp;
}
```

![](../../.gitbook/assets/screen-shot-2018-12-09-at-4.45.21-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-09-at-4.45.54-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-09-at-4.45.59-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-09-at-4.46.07-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-09-at-4.46.35-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-09-at-4.46.52-pm.png)

这里有非常重要的一个技巧，就是记忆实际index的位置，因为java并没有python切片的函数，所以实际在get Array的时候，得到的整个Array

* 这里主要是通过int k来记忆之前开始的位置
* 同样这里也需要修改findSmallest，在传入的参数之中应该有int start

```java
public class Sort {
    public static void sort(String[] x){
        sort(x, 0);
    }

    private static void sort(String[] x, int start) {
        if (start == x.length()) {
            return ;
        }
        int smallest = findSmallest(x, start);
        Swap(x, start, smallest);
        sort(x, start + 1);
    }

    public static String findSmallest(String[] x, int start) {
        int smallestIndex = 0;
        for (int x = start; i < x.length; i += 1) {
            int cmp = x[i].compareTo(x[smallestIndex]);
            if (cmp < 0 ) {
                smallestIndex = i;
            }
        }
        return x[smallestIndex];
    }
    
    public static void Swap(String x[], int a , int b){
        String temp = x[a];
        x[a] = x[b];
        x[b] = temp;
    }
}
```

**Simpler JUnit Tests**

![](../../.gitbook/assets/screen-shot-2018-12-09-at-4.47.50-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-09-at-4.47.57-pm.png)

这里使用@org.junit.Test可以不用手动运行main function，因此非常简便，但是这是在intellij环境下的，并没有在其他的IDE或者文本编辑器下实际运行过，所以并不知道实际效果。

![](../../.gitbook/assets/screen-shot-2018-12-09-at-4.48.03-pm.png)

#### **Testing Philosophy**

![](../../.gitbook/assets/screen-shot-2018-12-09-at-4.49.44-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-09-at-4.49.51-pm.png)

对于test来说，有利有弊吧，这里就是抓哟讨论了一下使用test的利弊

![](../../.gitbook/assets/screen-shot-2018-12-09-at-4.50.21-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-09-at-4.50.27-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-09-at-4.50.32-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-09-at-4.51.13-pm.png)

* junit
* Unit test
* Integration Test

#### **More On JUnit \(Extra\)**

![](../../.gitbook/assets/screen-shot-2018-12-09-at-4.51.44-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-09-at-4.51.49-pm.png)

## 8.  Inheritance, Implements

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.24.57-pm%20%281%29.png)

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.25.02-pm.png)

这里希望解决的是，如果code从SLlist变到ALlist，是否找到最长元素还可以工作

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.25.11-pm.png)

* String longest\(**SLList**&lt;String&gt; list\) -&gt; String longest\(**AList**&lt;String&gt; list\)
* 对原函数进行重载

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.26.04-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.26.10-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.26.16-pm.png)

* 重载的劣势是非常难以维护

**Hypernyms, Hyponyms, and Interface Inheritance**

hypernyms - 上位词

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.27.04-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.27.08-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.27.12-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.27.22-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.27.25-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.27.30-pm.png)

**Overriding vs. Overloading**

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.28.37-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.28.42-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.28.48-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.28.52-pm.png)

**Interface Inheritance**

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.29.40-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.29.45-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.29.51-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.29.56-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.30.00-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.30.04-pm.png)

**Implementation Inheritance: Default Methods**

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.31.12-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.31.17-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.31.23-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.31.28-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.31.31-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.31.36-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.31.40-pm.png)

**Static and Dynamic Type, Dynamic Method Selection**

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.33.15-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.33.19-pm.png)

**More Dynamic Method Selection, Overloading vs. Overriding**

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.34.06-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.34.10-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.34.14-pm.png)

**Interface vs. Implementation Inheritance**

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.35.12-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.35.16-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.35.24-pm.png)



