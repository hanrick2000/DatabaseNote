# CS 61B \(2\)

## 6. ALists, Resizing, vs. SLists

**A Last Look at Linked Lists**

* 首先回顾了之前实现的链表主要操作

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.07.09-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.07.16-pm.png)

* 对于链表来说因为没有相应的索引，所以要得到某个数需要遍历全链表来得到这个数，平均的时间复杂度是O\(n\)
* 如果有可能使用Array，那么这个时间复杂度就会下降到O\(1\)

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.07.23-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.07.28-pm.png)

**Naive Array Lists**

* Array主要的特点就是Random Access - 随机访问，在硬件中的存储是连续的地址，因而在随机访问的时候就会非常非常快，而链表所指向的地址则是离散且分散的
* 这里提到了cs61c 比较偏向底层，有时间可以看一看

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.08.42-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.08.46-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.08.52-pm.png)

在这里具体的实现是非常重要也需要自己实际去做一遍的，不要因为简单就一下跳过:

* 规律是每次新加数的index就是size，因为size是从0开始的，所以每次对size同时进行调整即可
* 通过对size的控制，就可以做到随机访问

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.08.58-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.09.04-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.09.11-pm.png)

* 因为实际控制这个array的是size，所以对于remove来说，只需要调整size，并返还现在remove的就可以
* 从一般意义上说，并不需要对之前的数进行复制，但是如果这个不是intArray，那么其实是需要对最后一位进行操作，并将值设置为Null的，因为涉及到了garbage collection

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.09.16-pm%20%281%29.png)

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.09.21-pm.png)

**Resizing Arrays**

因为在java以及c之类的静态语言中，每次需要申请一个定额的空间，因此会出现一个空间用尽的问题，具体来讲就是超过了整个array的长度，这时候就需要对array进行resize

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.11.46-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.12.05-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.12.12-pm.png)

具体实现来说:

* 先new一个新的array，然后将之前的数复制到这个新的array里面，然后再将新的值放去新array里

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.12.47-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.12.53-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.12.57-pm.png)

这种处理方法的弊端是慢，因为对于array来说，只对size + 1进行复制，需要进行的操作比较多，所以后面实际实现的是倍增法

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.13.02-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.14.07-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.14.13-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.14.19-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.14.25-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.14.29-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.14.33-pm%20%281%29.png)

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.14.38-pm.png)

* 倍增法的思路可以有效地将整体的运算时间进行下降

**Generic ALists**

通用的ArrayList，需要不指定特殊的数据种类，而根据需要来设置实际存储的值

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.17.00-pm.png)

这里比较重要的是：

* （Glorp \[\]）new Object\[8\] 这个操作，目前来说还不是很清楚，在后面的casting里面应该会涉及到

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.17.07-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.17.12-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.17.25-pm.png)

这里主要是设为null之后，Java会清空不需要的objects，从而不会使原来的指向关系和存储的数值都变成“游荡”的孤儿。

**Obscurantism in Java**

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.18.25-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-01-at-4.18.32-pm.png)

* 主要是一些编程技巧，这里应该使用Private来限制其他人对这个对象的访问

## 7. Testing

程序员需要对code进行test来确保他们的程序能够运行，即使如此也很难确保程序能够正常运行，所谓的test都是尽可能接近程序的模拟来帮助debug。

#### **Ad Hoc Testing vs. JUnit**

```java
public static void testSort() {
    String[] input = {"I", "have", "an", "egg"};
    String[] expected = {"an", "egg", "have", "I"};
    Sort.sort(input);

    if (input != expected) {  // 这里如果写了 != 实际比较的事两者的地址是否一样
        System.out.println("Error!");
    }
    
    // 使用这种写法就是比较这个string list里面每一个元素是否一样    
    if (!java.util.Arrays.equals(input, expected)) {  
        System.out.println("Error!");
    }
}
```

下面的新写法就是尝试不实用java.util.Arrays，直接使用循环

![](../../.gitbook/assets/screen-shot-2018-12-09-at-4.44.04-pm.png)

实际coding的过程中，jUnit会自动做这些事情，类似于Python的断言函数来自动报错和检查

* org.junit.Assert.assertArrayEquals\(expected, input\);

![](../../.gitbook/assets/screen-shot-2018-12-09-at-4.44.09-pm.png)

* deprecated
  * 有时候因为代码修改需要淘汰一些函数，这里的问题是为什么不remove这个函数
  * 主要是为了保证以前的code也是可以运行的，这样可以做一个缓慢的过度

#### **Selection Sort**

* 永远把最小的提前

![](../../.gitbook/assets/screen-shot-2018-12-09-at-4.45.14-pm.png)

```java
// 找到最小的值

public static String findSmallest(String[] x) {
    int smallestIndex = 0;
    for (int x = 0; i < x.length; i += 1) {
        if (x[i] < x[smallestIndex]) { // 这里因为比较的事字符串，所以会报错
            smallestIndex = i;
        }
    }
    return smallestIndex;
}

// 修正

public static String findSmallest(String[] x) {
    int smallestIndex = 0;
    for (int x = 0; i < x.length; i += 1) {
        int cmp = x[i].compareTo(x[smallestIndex]); // 改成字符串比较
        if (cmp < 0 ) {
            smallestIndex = i;
        }
    }
    return smallestIndex;
}
```

Josh Hug真的是非常好的老师，在上课的过程中讲了如何debug，而且是从一个完全初学者的角度去理解，实现了找到最小的之后，只需要对内容进行swap即可。

```java
public static void Swap(String x[], int a , int b){
    String temp = x[a];
    x[a] = x[b];
    x[b] = temp;
}
```

![](../../.gitbook/assets/screen-shot-2018-12-09-at-4.45.21-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-09-at-4.45.54-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-09-at-4.45.59-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-09-at-4.46.07-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-09-at-4.46.35-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-09-at-4.46.52-pm.png)

这里有非常重要的一个技巧，就是记忆实际index的位置，因为java并没有python切片的函数，所以实际在get Array的时候，得到的整个Array

* 这里主要是通过int k来记忆之前开始的位置
* 同样这里也需要修改findSmallest，在传入的参数之中应该有int start

```java
public class Sort {
    public static void sort(String[] x){
        sort(x, 0);
    }

    private static void sort(String[] x, int start) {
        if (start == x.length()) {
            return ;
        }
        int smallest = findSmallest(x, start);
        Swap(x, start, smallest);
        sort(x, start + 1);
    }

    public static String findSmallest(String[] x, int start) {
        int smallestIndex = 0;
        for (int x = start; i < x.length; i += 1) {
            int cmp = x[i].compareTo(x[smallestIndex]);
            if (cmp < 0 ) {
                smallestIndex = i;
            }
        }
        return x[smallestIndex];
    }
    
    public static void Swap(String x[], int a , int b){
        String temp = x[a];
        x[a] = x[b];
        x[b] = temp;
    }
}
```

**Simpler JUnit Tests**

![](../../.gitbook/assets/screen-shot-2018-12-09-at-4.47.50-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-09-at-4.47.57-pm.png)

这里使用@org.junit.Test可以不用手动运行main function，因此非常简便，但是这是在intellij环境下的，并没有在其他的IDE或者文本编辑器下实际运行过，所以并不知道实际效果。

![](../../.gitbook/assets/screen-shot-2018-12-09-at-4.48.03-pm.png)

#### **Testing Philosophy**

![](../../.gitbook/assets/screen-shot-2018-12-09-at-4.49.44-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-09-at-4.49.51-pm.png)

对于test来说，有利有弊吧，这里就是抓哟讨论了一下使用test的利弊

![](../../.gitbook/assets/screen-shot-2018-12-09-at-4.50.21-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-09-at-4.50.27-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-09-at-4.50.32-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-09-at-4.51.13-pm.png)

* junit
* Unit test
* Integration Test

#### **More On JUnit \(Extra\)**

![](../../.gitbook/assets/screen-shot-2018-12-09-at-4.51.44-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-09-at-4.51.49-pm.png)

## 8.  Inheritance, Implements

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.24.57-pm%20%281%29.png)

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.25.02-pm.png)

这里希望解决的是，如果code从SLlist变到ALlist，是否找到最长元素还可以工作

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.25.11-pm.png)

* String longest\(**SLList**&lt;String&gt; list\) -&gt; String longest\(**AList**&lt;String&gt; list\)
* 对原函数进行重载

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.26.04-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.26.10-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.26.16-pm.png)

* 重载的劣势是非常难以维护

**Hypernyms, Hyponyms, and Interface Inheritance**

hypernyms - 上位词

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.27.04-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.27.08-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.27.12-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.27.22-pm.png)

发现它们都有同样的methods，所以主要实现的也在这里

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.27.25-pm.png)

java的继承方法主要是通过implements，比较神奇

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.27.30-pm.png)

**Overriding vs. Overloading**

* overriding 覆盖和重写，会改变函数的方法和内容
* overloading 重载，只是改变函数的类型

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.28.37-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.28.42-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.28.48-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.28.52-pm.png)

* @override主要只是帮助理解和debug ，来看这个方法是否是被重写了

**Interface Inheritance**

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.29.40-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.29.45-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.29.51-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.29.56-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.30.04-pm.png)

**Implementation Inheritance: Default Methods**

* default 关键词 会强迫子类继承超类的方法

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.31.12-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.31.28-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.31.31-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.31.40-pm.png)

**Static and Dynamic Type, Dynamic Method Selection**

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.33.15-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.33.19-pm.png)

每次override之后，那么相应的类型也会相应改变

#### **More Dynamic Method Selection, Overloading vs. Overriding**

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.34.06-pm.png)

* a.greet\(d\) 
* a.sniff\(d\) 重写了
* d.fatter\(d\) 重载了，并没有同样的signatures

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.34.10-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.34.14-pm.png)

**Interface vs. Implementation Inheritance**

* interface更像是一种抽象，只是说它是什么，也就是后面说的is的问题
* interface 的实现，则表明了具体一种方法是如何被实现的

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.35.12-pm.png)

![](../../.gitbook/assets/screen-shot-2018-12-16-at-3.35.16-pm.png)

## 9. Extends, Casting, Higher Order Functions

**Implementation Inheritance: Extends**

* implements 指的实现具体的interface
* extends 则是主要继承原因借口和类的方法和成员

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.16.38-am%20%282%29.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.16.42-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.16.47-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.18.04-am.png)

* 需要注意的是每一次重新都要确定重写的到底是哪个方法，如果没有super，会默认为之前的

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.18.10-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.18.16-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.18.21-am.png)

* 本质上来说所以的类都继承自ojbect
* 一定要想是is还是has的问题

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.18.26-am.png)

**Encapsulation**

* 封装这里我比较熟悉就不多说了

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.19.39-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.19.43-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.19.47-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.19.53-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.19.59-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.20.03-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.20.06-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.20.10-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.20.17-am.png)

**Type Checking and Casting**

* 类型的强制转换是 使用（），这里比较重要，因为是根据类型来call函数的

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.22.03-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.22.12-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.22.21-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.22.25-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.22.28-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.22.32-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.22.35-am.png)

**Dynamic Method Selection and Casting Puzzle**

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.24.59-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.25.06-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.25.12-am.png)

**Higher Order Functions**

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.26.08-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.26.12-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.26.16-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.26.21-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.26.25-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.26.29-am.png)

## 10. Subtype Polymorphism vs. HoFs

**Dynamic Method Selection Puzzle \(Online Only\)**

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.29.02-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.29.06-am%20%281%29.png)

* 第一行，是否showdog是object? 是，所以可以
* 第二行，showdog是否可以强制转换为showdog? 可以
* 所以 sdx就是showdog，showdog有bark方法么？有
* 第四行，dog是一个dog？是
* dx是dog，dog 有 bark 方法么？有
* 第六行，还是dog的bark方法
* 第七行，dog是object? 是
* o3 是object 有bark方法么？没有

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.29.09-am.png)

**Subtype Polymorphism**

子类 - 同一函数的输入类型为不同的类型，如int，string

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.30.31-am%20%281%29.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.30.36-am.png)

* 高阶函数和子类是比较不同的
  * 高级函数依赖于其他函数进行判断
  * 子类则是自己就可以通过比较判断来确定返回的类型

**DIY Comparison**

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.31.30-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.31.35-am.png)

dog是一个object，所以第三个没问题，那么同理因为传入的是dogs，也是一个object list，所以第一个也是没有问题的，第二个就有问题了，因为无法进行比较，object之间是无法比较的

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.31.39-am.png)

因为这里出了问题， 所以不能采用打擂台的形式来确认最大的，而是要用下面的方式来寻找最大的，这里没有详细讲解是怎么实现的，而是侧重于默认Dog有这个方法。

* 具体来说就是给一个“狗链”，然后找到“狗链”中size最大的狗，然后返回这个狗

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.31.42-am.png)

如果想要fix原有的问题怎么办，其实很类似，还是给一个狗链比较size，在c++和python里面， 实际上可以重新定义这里比较的意义，然而在java中，这个是不能实现的，只能建立一个interface。

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.31.47-am.png)

* 这里就是创建了一个接口，而这个接口具有对Dog比较的方法，这里跟着Hug写了一下
* 然后Dog实现了这个接口，也就是说可以使用这个接口

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.31.50-am.png)



![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.31.54-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.31.58-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.32.01-am.png)

* 好处在于会自动根据类型来实现同一方法，从而减少了实际需要的重复劳动

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.32.06-am%20%281%29.png)

因为dog实现了接口，当dog没有compareTo方法的时候，Dog是不能通过编译的

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.32.10-am%20%281%29.png)

DogLauncher不能编译的原因是当它call max函数的时候，给的是dogs，而max期望的时候OurComparables，因此这里会直接使得编译无法通过

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.32.18-am.png)

**Comparables**

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.35.15-am.png)

因为强制转换的存在，会使得代码整体比较复杂，每次都要强制转换，需要利用java自带的方法来实现，它本身自己会接入一个generic 类型，根据需要自行转换类型，但是在实际使用的时候，还是需要\(Dog\) 对Maximizer来进行强制转换

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.35.19-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.35.23-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.35.27-am.png)

**Comparators**

根据什么来进行排序

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.38.24-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.38.28-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.38.31-am.png)

这里如果使用高阶函数，那么需要传递非常多的comapre函数，因而非常的不方便

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.38.35-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.38.38-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.38.42-am.png)

这里的技术比较复杂，首先需要通过内置的java.util.Comparator新建一个接口，  然后实现这个接口，在实际的操作中通过GetComparator  再对函数进行封装

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.38.46-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.38.48-am.png)

## 11. Libraries, Abstract Classes, Packages

**Java Libraries**

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.45.11-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.45.18-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.45.22-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.45.25-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.45.29-am%20%281%29.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.45.33-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.45.36-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.45.39-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.45.43-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.45.48-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.45.52-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.45.56-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.46.03-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.46.07-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.46.10-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.46.17-am.png)

**Interfaces and Abstract Classes**

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.51.46-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.51.49-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.51.54-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.51.57-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.52.14-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.52.17-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.52.20-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.52.29-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.52.34-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.52.38-am.png)

**Packages**

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.55.17-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.55.20-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.55.24-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.55.27-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.55.30-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.55.34-am.png)

**Extra Slides For Command Line Users \(no video\)**

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.57.05-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.57.09-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.57.12-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.57.15-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.57.19-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.57.22-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.57.26-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.57.29-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.57.34-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.57.37-am.png)

![](../../.gitbook/assets/screen-shot-2018-12-24-at-11.57.41-am.png)

