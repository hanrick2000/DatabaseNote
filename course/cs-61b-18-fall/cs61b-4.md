# CS 61B \(3\) - 算法分析与数据结构

## **17: Introduction to Asymptotic Analysis**

这里因为主要是将如何分析算法以及如何入门，这里我已经非常熟悉了，毕竟刷了非常长时间的算法，所以没有过度关注这里，我会在自己熟悉的地方稍微标注一下。

![](../../.gitbook/assets/image%20%28269%29.png)

![](../../.gitbook/assets/image%20%28382%29.png)

**Intuitive Runtime Characterizations**

![](../../.gitbook/assets/image%20%28377%29.png)

![](../../.gitbook/assets/image%20%28403%29.png)

![](../../.gitbook/assets/image%20%287%29.png)

![](../../.gitbook/assets/image%20%2863%29.png)

![](../../.gitbook/assets/image%20%28124%29.png)

![](../../.gitbook/assets/image%20%28356%29.png)

![](../../.gitbook/assets/image%20%28448%29.png)

![](../../.gitbook/assets/image%20%28117%29.png)

![](../../.gitbook/assets/image%20%28290%29.png)

![](../../.gitbook/assets/image%20%28134%29.png)

这里涉及到了如何度量具体的时间花费的问题 :

* 一种是多跑几次实际测一测
* 一种是从数学的角度，来进行具体的计算给出一个公式

![](../../.gitbook/assets/image%20%28436%29.png)

![](../../.gitbook/assets/image%20%28259%29.png)

![](../../.gitbook/assets/image%20%28234%29.png)

![](../../.gitbook/assets/image%20%28244%29.png)

**Worst Case Order of Growth**

![](../../.gitbook/assets/image%20%28404%29.png)

![](../../.gitbook/assets/image%20%28286%29.png)

![](../../.gitbook/assets/image%20%28108%29.png)

![](../../.gitbook/assets/image%20%28304%29.png)

![](../../.gitbook/assets/image%20%28454%29.png)

![](../../.gitbook/assets/image%20%28112%29.png)

![](../../.gitbook/assets/image%20%28107%29.png)

![](../../.gitbook/assets/image%20%28217%29.png)

![](../../.gitbook/assets/image%20%2873%29.png)

![](../../.gitbook/assets/image%20%28442%29.png)

因为实际的运算时间是非常受限的，它显著地受单个计算机性能以及在某一时点计算机状态的约束：

* 所以，对于渐进性的分析，更多关注单个操作的最坏时间，忽略了低阶和常数项，因为同最高阶相比，它们实际的影响太小了

![](../../.gitbook/assets/image%20%28137%29.png)

![](../../.gitbook/assets/image%20%28161%29.png)

**Simplified Analysis**

![](../../.gitbook/assets/image%20%28353%29.png)

![](../../.gitbook/assets/image%20%2890%29.png)

![](../../.gitbook/assets/image%20%28300%29.png)

![](../../.gitbook/assets/image%20%2896%29.png)

**Big-Theta**

![](../../.gitbook/assets/image%20%28165%29.png)

![](../../.gitbook/assets/image%20%28354%29.png)

![](../../.gitbook/assets/image%20%2833%29.png)

![](../../.gitbook/assets/image%20%28439%29.png)

![](../../.gitbook/assets/image%20%2819%29.png)

![](../../.gitbook/assets/image%20%28151%29.png)

![](../../.gitbook/assets/image%20%28459%29.png)

![](../../.gitbook/assets/image%20%28383%29.png)



![](../../.gitbook/assets/image%20%28132%29.png)

大小O主要是用来分析运算时间的上界和下界，通过夹逼得方式来获得一个大致的运行时间，这些基本都比较基础

## 18. Asymptotics II

**Example 1/2:For Loops**

![](../../.gitbook/assets/image%20%28111%29.png)

![](../../.gitbook/assets/image%20%28319%29.png)

![](../../.gitbook/assets/image%20%28376%29.png)

![](../../.gitbook/assets/image%20%28206%29.png)

![](../../.gitbook/assets/image%20%28193%29.png)

![](../../.gitbook/assets/image%20%28276%29.png)

![](../../.gitbook/assets/image%20%28327%29.png)

![](../../.gitbook/assets/image%20%28156%29.png)

![](../../.gitbook/assets/image%20%28443%29.png)

![](../../.gitbook/assets/image%20%2866%29.png)

**Example 3: Recursion**

![](../../.gitbook/assets/image%20%2838%29.png)

![](../../.gitbook/assets/image%20%28176%29.png)

![](../../.gitbook/assets/image%20%2867%29.png)

![](../../.gitbook/assets/image%20%2825%29.png)

![](../../.gitbook/assets/image%20%28444%29.png)

![](../../.gitbook/assets/image%20%28409%29.png)

![](../../.gitbook/assets/image%20%28346%29.png)

![](../../.gitbook/assets/image%20%2846%29.png)

![](../../.gitbook/assets/image%20%28195%29.png)

![](../../.gitbook/assets/image%20%2851%29.png)

![](../../.gitbook/assets/image%20%28297%29.png)

**Example 4: Binary Search**

![](../../.gitbook/assets/image%20%28349%29.png)

![](../../.gitbook/assets/image%20%2823%29.png)

![](../../.gitbook/assets/image%20%28437%29.png)

**Example 5: Mergesort**

![](../../.gitbook/assets/image%20%28219%29.png)

![](../../.gitbook/assets/image%20%28266%29.png)

![](../../.gitbook/assets/image%20%28146%29.png)

![](../../.gitbook/assets/image%20%28172%29.png)

![](../../.gitbook/assets/image%20%2828%29.png)

![](../../.gitbook/assets/image%20%28153%29.png)

![](../../.gitbook/assets/image%20%28463%29.png)

![](../../.gitbook/assets/image%20%28261%29.png)

![](../../.gitbook/assets/image%20%28320%29.png)

![](../../.gitbook/assets/image%20%28254%29.png)

![](../../.gitbook/assets/image%20%2847%29.png)

![](../../.gitbook/assets/image%20%2889%29.png)

![](../../.gitbook/assets/image%20%28235%29.png)

![](../../.gitbook/assets/image%20%28441%29.png)

这里主要是给出来很多例子来说明，具体的时间复杂度是如何计算的，根据个人经验，应该在刷题的时候搞清楚具体的计算复杂度，有很多递推式之类的问题不容易算出来，更应该侧重于找规律。

## 19. Asymptotics II

**Big O Notation**

![](../../.gitbook/assets/image%20%2826%29.png)

![](../../.gitbook/assets/image%20%28313%29.png)

![](../../.gitbook/assets/image%20%2844%29.png)

![](../../.gitbook/assets/image%20%28252%29.png)

![](../../.gitbook/assets/image%20%286%29.png)

**Runtime Analysis Subtleties**

![](../../.gitbook/assets/image%20%28410%29.png)

![](../../.gitbook/assets/image%20%28149%29.png)

![](../../.gitbook/assets/image%20%28243%29.png)

![](../../.gitbook/assets/image%20%28390%29.png)

![](../../.gitbook/assets/image%20%28355%29.png)

![](../../.gitbook/assets/image%20%28401%29.png)

![](../../.gitbook/assets/image%20%28301%29.png)

![](../../.gitbook/assets/image%20%28395%29.png)

![](../../.gitbook/assets/image%20%28307%29.png)

![](../../.gitbook/assets/image%20%2829%29.png)

![](../../.gitbook/assets/image%20%28423%29.png)

**Big Omega**

![](../../.gitbook/assets/image%20%28384%29.png)

![](../../.gitbook/assets/image%20%28369%29.png)

![](../../.gitbook/assets/image%20%28323%29.png)

![](../../.gitbook/assets/image%20%28425%29.png)

**Amortized Analysis \(Intuitive\)**

![](../../.gitbook/assets/image%20%2897%29.png)

![](../../.gitbook/assets/image%20%28192%29.png)

![](../../.gitbook/assets/image%20%28336%29.png)

![](../../.gitbook/assets/image%20%28400%29.png)

![](../../.gitbook/assets/image%20%28213%29.png)

![](../../.gitbook/assets/image%20%28118%29.png)

![](../../.gitbook/assets/image%20%2870%29.png)

![](../../.gitbook/assets/image%20%28411%29.png)

**Amortized Analysis \(Rigorous\)**

![](../../.gitbook/assets/image%20%28197%29.png)

![](../../.gitbook/assets/image%20%28126%29.png)

![](../../.gitbook/assets/image%20%28321%29.png)

![](../../.gitbook/assets/image%20%28208%29.png)

![](../../.gitbook/assets/image%20%28302%29.png)

![](../../.gitbook/assets/image%20%2850%29.png)

![](../../.gitbook/assets/image%20%28398%29.png)

![](../../.gitbook/assets/image%20%28105%29.png)

![](../../.gitbook/assets/image%20%2827%29.png)

![](../../.gitbook/assets/image%20%28210%29.png)

![](../../.gitbook/assets/image%20%2830%29.png)

![](../../.gitbook/assets/image%20%28278%29.png)

![](../../.gitbook/assets/image%20%28402%29.png)

**Complexity Theory \(Sneak Preview \(Extra\)**

![](../../.gitbook/assets/image%20%2836%29.png)

![](../../.gitbook/assets/image%20%28362%29.png)

![](../../.gitbook/assets/image%20%28178%29.png)

整体来说对于算法，我已经非常熟悉了，这里就直接过了。



## 20. Disjoint Sets

并查集是非常重要的一种数据结构，主要用来解决连通性问题 - 动态连通性

![](../../.gitbook/assets/image%20%2893%29.png)

![](../../.gitbook/assets/image%20%28227%29.png)

![](../../.gitbook/assets/image%20%28135%29.png)

![](../../.gitbook/assets/image%20%28122%29.png)

![](../../.gitbook/assets/image%20%28142%29.png)

因为刷过题，这里其实是找father的过程，通过fatehr实现联通集

![](../../.gitbook/assets/image%20%2888%29.png)

![](../../.gitbook/assets/image%20%28426%29.png)

**Quick Find**

查找操作很粗暴，就是看一下father是不是一样

![](../../.gitbook/assets/image%20%28216%29.png)

![](../../.gitbook/assets/image%20%28253%29.png)

* 一种是返回集合里面所有的元素，明显不行，要是10000个元素呢
* 另一种是移sets里面，和上面是一样的还是O\(L\)

![](../../.gitbook/assets/image%20%28103%29.png)

其实还是需要一个同样size的Array，然后指向自己的father，father一样就是一个集合呗，这样就是O\(1\)了

![](../../.gitbook/assets/image%20%28115%29.png)

这里连接需要O\(n\)的时间，太慢了

![](../../.gitbook/assets/image%20%28447%29.png)

**Quick Union**

![](../../.gitbook/assets/image%20%28180%29.png)

![](../../.gitbook/assets/image%20%2813%29.png)

![](../../.gitbook/assets/image%20%28460%29.png)

这里就是选代表，看看有没有father，赋值father就可以了，把3的father或者0的father改一下就行

![](../../.gitbook/assets/image%20%28394%29.png)

![](../../.gitbook/assets/image%20%28345%29.png)

这样会使得整个树非常的高，最坏还是O\(n\)，这里需要flatten这个树，包括后面的压缩路径

![](../../.gitbook/assets/image%20%2862%29.png)

![](../../.gitbook/assets/image%20%28100%29.png)

![](../../.gitbook/assets/image%20%28360%29.png)

**Weighted Quick Union**

![](../../.gitbook/assets/image%20%28265%29.png)

另一种也就是说记录实际的树大小，也就是实际需要改变的数目，然后只全部修改数目小的那一个数

![](../../.gitbook/assets/image%20%28317%29.png)

![](../../.gitbook/assets/image%20%28370%29.png)

![](../../.gitbook/assets/image%20%2860%29.png)

![](../../.gitbook/assets/image%20%28168%29.png)

![](../../.gitbook/assets/image%20%28247%29.png)

这种方法使得整体时间复杂度下降到O\(logN\)，主要是每次都会对N一刀切，分成两组，比较两组的实际大小

**Path Compression**

路径压缩是最优的方法

![](../../.gitbook/assets/image%20%28273%29.png)

每次isConnected的时候，遍历所有的节点，修改它们的值，从而将计算复杂度下降到lg \* N ~ 1，阿克曼函数的反函数

![](../../.gitbook/assets/image%20%288%29.png)

![](../../.gitbook/assets/image%20%28104%29.png)

![](../../.gitbook/assets/image%20%2853%29.png)

![](../../.gitbook/assets/image%20%28415%29.png)

![](../../.gitbook/assets/image%20%28462%29.png)

Reference :

{% embed url="https://blog.csdn.net/dm\_vincent/article/details/7655764" %}

最终，整体时间复杂度会下降到线性

## 21. Trees, BSTs

![](../../.gitbook/assets/image%20%28242%29.png)

![](../../.gitbook/assets/image%20%2892%29.png)

* 一种是直接加入额外的链接进行快速跳转

![](../../.gitbook/assets/image%20%28342%29.png)

![](../../.gitbook/assets/image%20%28267%29.png)

另一种就是使用二叉搜索树，binary search tree

**BST Definitions**

![](../../.gitbook/assets/image%20%28330%29.png)

![](../../.gitbook/assets/image%20%28373%29.png)

这里强调了具体的二叉树的定义，主要问题在于rooted trees，这里只是保证了二叉树，而不一定是二叉搜索树

![](../../.gitbook/assets/image%20%28347%29.png)

二叉搜索树的特点是，左边小与中间，中间小于右边

![](../../.gitbook/assets/image%20%2894%29.png)

**BST Operations**

![](../../.gitbook/assets/image%20%2849%29.png)

基本操作就是 ：小了往左，大了往右走

![](../../.gitbook/assets/image%20%28381%29.png)

![](../../.gitbook/assets/image%20%28256%29.png)

![](../../.gitbook/assets/image%20%28233%29.png)

![](../../.gitbook/assets/image%20%28175%29.png)

这里主要讲解了插入的过程，先查找，如何需要可以互换或者加入新节点

* 这里提到了一些不太好的习惯，右边的那里 - arms length recursion

![](../../.gitbook/assets/image%20%28147%29.png)

![](../../.gitbook/assets/image%20%28399%29.png)

没儿子的，直接删掉就行

![](../../.gitbook/assets/image%20%28270%29.png)

一个儿子的，指向左儿子或者右儿子，然后删掉就行

![](../../.gitbook/assets/image%20%28429%29.png)

要删有两个儿子的就相对复杂了，需要和原来的节点比较，这里具体说一下

* 要删dog，应该遍历左儿子的最右边，也就是cat，然后遍历右儿子的最左边，也就是elf
* 然后选举产生谁是新的root，也就是比较一下

![](../../.gitbook/assets/image%20%2841%29.png)

![](../../.gitbook/assets/image%20%28127%29.png)

用到上面说到的方法就可以了

**BST Performance**

![](../../.gitbook/assets/image%20%28281%29.png)

![](../../.gitbook/assets/image%20%28351%29.png)

![](../../.gitbook/assets/image.png)

![](../../.gitbook/assets/image%20%28329%29.png)

这里希望解决的避免 『spindly』tree的形式，这里少了两个视频，一个是插入节点，平均来讲还是维持了一个较好的树的高度，另一个是删除节点，它并不能很好地位置树的高度

这里josh说，尽管两者都是随机的，但是大家也不知道为什么删除操作会这样

**BST Implementation Tips**

![](../../.gitbook/assets/image%20%2868%29.png)

## 22. Balanced BSTs

这里提到了一个渐进性的符号表示问题：

* Big O 算是上界，Bit Omega 算是下界，Bit Theta则是差不多多少
* 既然从基础重新学习和夯实了，那么就应该深刻地去理解，并搞懂每一个琐碎的知识点

{% embed url="https://blog.csdn.net/zuochao\_2013/article/details/53428837" %}

![](../../.gitbook/assets/image%20%28159%29.png)

接上面，这里就是说随机插入的话，树的高度是O\(logN\)

**Tree Rotation**

![](../../.gitbook/assets/image%20%28338%29.png)

RotateLeft的意思是说，将G的右节点P作为root，然后将P的左节点给G，然后G变成P的儿子。

![](../../.gitbook/assets/image%20%282%29.png)

![](../../.gitbook/assets/image%20%28396%29.png)

![](../../.gitbook/assets/image%20%28372%29.png)

{% embed url="https://docs.google.com/presentation/d/1pfkQENfIBwiThGGFVO5xvlVp7XAUONI2BwBqYxib0A4/edit\#slide=id.g465b5392c\_00" %}

上面的链接具体说明了如何使用rotation来得到一个平衡的二叉树，也就是每次的插入和删除后都需要rotate一下

**B-trees / 2-3 trees / 2-3-4 trees**

![](../../.gitbook/assets/image%20%28220%29.png)

![](../../.gitbook/assets/image%20%28433%29.png)

这里发现的不平衡的问题来源于加入叶子，所以如果不加入叶子，就会保持整个树的高度不变，而新加入的叶子都会堆在一起

![](../../.gitbook/assets/image%20%28325%29.png)

![](../../.gitbook/assets/image%20%28284%29.png)

这种方式的问题在于，会有一个非常大的叶子，这会使得具体的运算非常的复杂

![](../../.gitbook/assets/image%20%28136%29.png)

![](../../.gitbook/assets/image%20%28283%29.png)

![](../../.gitbook/assets/image%20%28446%29.png)

如果将之前的大叶子分割，并将中间的向上移动，会减少子叶的大小，但是这会使得上一个叶子变得不合理，这里新的解决方法就是，将子叶进行详细划分，这样可以进行两次比较

![](../../.gitbook/assets/image%20%28221%29.png)

这里需要理解一下这个结构，如果小于o，就是n，如果大于o但小于q，就是p，不然就是rs

![](../../.gitbook/assets/image%20%28215%29.png)

![](../../.gitbook/assets/image%20%28184%29.png)

![](../../.gitbook/assets/image%20%28120%29.png)

![](../../.gitbook/assets/image%20%28413%29.png)

![](../../.gitbook/assets/image%20%28386%29.png)

这种叫做Splitting-trees 也就是 2-3 tree，没分一次整体高度加一

![](../../.gitbook/assets/image%20%28393%29.png)

所以整体树的高度在于logM\(N\)和log2\(N\) :

* M = 4 就是 2-3-4 tree，M = 3 就是 2-3 tree，M确定了最大的儿子数

![](../../.gitbook/assets/image%20%28339%29.png)

![](../../.gitbook/assets/image%20%28182%29.png)

在这里稍微小结一下，B tree的好处是什么，是限制了整个树的高度，从而使得查找非常的快，但是呢，在写入过程是比较复杂的，要看一看是不是满了，然后上下移动，这也是为什么它这么适合文件系统

**Red-Black Trees**

![](../../.gitbook/assets/image%20%28113%29.png)

![](../../.gitbook/assets/image%20%28262%29.png)

因为B tree实现不容易，而二叉搜索树又不是平衡的，所以从2-3 tree开始探索如何解决平衡的问题

![](../../.gitbook/assets/image%20%28144%29.png)

![](../../.gitbook/assets/image%20%28160%29.png)

![](../../.gitbook/assets/image%20%28145%29.png)

利用2-3 tree的想法，虚拟出来一个节点，利用红色的线来连接，这就是红色部分

![](../../.gitbook/assets/image%20%28251%29.png)

这里重复了一下，因为觉得这种基本概念非常重要:

* 一个点最多只有一条红线
* 从根节点到叶子的黑线是一样的
* 红线都是左倾的，所以也叫LLRB

![](../../.gitbook/assets/image%20%2898%29.png)

![](../../.gitbook/assets/image%20%28158%29.png)

**Maintaining Isometry Through Rotations \(Optional\)**

这里还是详细看了一下具体2-3 tree如何变成红黑树

![](../../.gitbook/assets/image%20%28128%29.png)

首先写成2-3 tree 的形式，然后建立红线水平虚拟节点，然后下移

![](../../.gitbook/assets/image%20%28264%29.png)

![](../../.gitbook/assets/image%20%28141%29.png)

增加节点的时候，先增加叶子的元素数量，再重复之前的操作

![](../../.gitbook/assets/image%20%2869%29.png)

![](../../.gitbook/assets/image%20%28162%29.png)

![](../../.gitbook/assets/image%20%28245%29.png)

![](../../.gitbook/assets/image%20%28154%29.png)

![](../../.gitbook/assets/image%20%28238%29.png)

![](../../.gitbook/assets/image%20%28326%29.png)

![](../../.gitbook/assets/image%20%28167%29.png)

几个小点:

* 2 - 3 tree是需要插入删除后 拆分的，而LLRB 是需要每次插入删除后旋转的

